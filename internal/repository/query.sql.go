// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BulkCreateDailyParams struct {
	ID        pgtype.UUID
	Stockid   pgtype.UUID
	Open      pgtype.Numeric
	High      pgtype.Numeric
	Low       pgtype.Numeric
	Close     pgtype.Numeric
	Adjclose  pgtype.Numeric
	Volume    pgtype.Int4
	Timestamp pgtype.Timestamp
}

type BulkCreateStocksParams struct {
	ID           pgtype.UUID
	Name         string
	Symbol       string
	Customsymbol string
	Scripttype   string
	Industry     pgtype.Text
	Isin         pgtype.Text
	Fno          bool
}

const createStock = `-- name: CreateStock :one
INSERT INTO stocks (
    id, name, symbol, customSymbol, scriptType, industry, isin, fno
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, created_at, updated_at, name, symbol, customsymbol, scripttype, industry, isin, fno
`

type CreateStockParams struct {
	ID           pgtype.UUID
	Name         string
	Symbol       string
	Customsymbol string
	Scripttype   string
	Industry     pgtype.Text
	Isin         pgtype.Text
	Fno          bool
}

func (q *Queries) CreateStock(ctx context.Context, arg CreateStockParams) (Stock, error) {
	row := q.db.QueryRow(ctx, createStock,
		arg.ID,
		arg.Name,
		arg.Symbol,
		arg.Customsymbol,
		arg.Scripttype,
		arg.Industry,
		arg.Isin,
		arg.Fno,
	)
	var i Stock
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Symbol,
		&i.Customsymbol,
		&i.Scripttype,
		&i.Industry,
		&i.Isin,
		&i.Fno,
	)
	return i, err
}

const getHistoricalStockPrices = `-- name: GetHistoricalStockPrices :many
SELECT d.timestamp, d.adjClose
FROM daily d
JOIN stocks s ON d.stockid = s.id
WHERE s.symbol = $1
  AND d.timestamp >= $2
  AND d.timestamp <= $3
  AND d.adjClose IS NOT NULL
ORDER BY d.timestamp
`

type GetHistoricalStockPricesParams struct {
	Symbol      string
	Timestamp   pgtype.Timestamp
	Timestamp_2 pgtype.Timestamp
}

type GetHistoricalStockPricesRow struct {
	Timestamp pgtype.Timestamp
	Adjclose  pgtype.Numeric
}

func (q *Queries) GetHistoricalStockPrices(ctx context.Context, arg GetHistoricalStockPricesParams) ([]GetHistoricalStockPricesRow, error) {
	rows, err := q.db.Query(ctx, getHistoricalStockPrices, arg.Symbol, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHistoricalStockPricesRow
	for rows.Next() {
		var i GetHistoricalStockPricesRow
		if err := rows.Scan(&i.Timestamp, &i.Adjclose); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestClosePrice = `-- name: GetLatestClosePrice :one
SELECT adjClose
FROM daily d
JOIN stocks s ON d.stockid = s.id
WHERE s.symbol = $1 AND d.timestamp <= $2
AND d.adjclose IS NOT NULL
ORDER BY d.timestamp DESC
LIMIT 1
`

type GetLatestClosePriceParams struct {
	Symbol    string
	Timestamp pgtype.Timestamp
}

func (q *Queries) GetLatestClosePrice(ctx context.Context, arg GetLatestClosePriceParams) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getLatestClosePrice, arg.Symbol, arg.Timestamp)
	var adjclose pgtype.Numeric
	err := row.Scan(&adjclose)
	return adjclose, err
}

const getStock = `-- name: GetStock :one
SELECT id, created_at, updated_at, name, symbol, customsymbol, scripttype, industry, isin, fno FROM stocks
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetStock(ctx context.Context, id pgtype.UUID) (Stock, error) {
	row := q.db.QueryRow(ctx, getStock, id)
	var i Stock
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Symbol,
		&i.Customsymbol,
		&i.Scripttype,
		&i.Industry,
		&i.Isin,
		&i.Fno,
	)
	return i, err
}

const getStocks = `-- name: GetStocks :many
SELECT id, created_at, updated_at, name, symbol, customsymbol, scripttype, industry, isin, fno FROM stocks
ORDER BY name
`

func (q *Queries) GetStocks(ctx context.Context) ([]Stock, error) {
	rows, err := q.db.Query(ctx, getStocks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stock
	for rows.Next() {
		var i Stock
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Symbol,
			&i.Customsymbol,
			&i.Scripttype,
			&i.Industry,
			&i.Isin,
			&i.Fno,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopStocksByReturn = `-- name: GetTopStocksByReturn :many
WITH one_year_ago_prices AS (
    SELECT DISTINCT ON (d.stockid)
        d.stockid,
        d.adjClose
    FROM
        daily d
    JOIN stocks s ON d.stockid = s.id
    WHERE
        d.timestamp <= ($1::timestamp - make_interval(months => $2::int))
        AND d.adjClose IS NOT NULL
        AND d.adjClose != 0
        AND ($3 = 'all' OR s.scriptType = $3)
    ORDER BY d.stockid, d.timestamp DESC
),
latest_prices AS (
    SELECT DISTINCT ON (d.stockid)
        d.stockid,
        d.adjClose
    FROM
        daily d
    JOIN stocks s ON d.stockid = s.id
    WHERE
        d.timestamp <= $1::timestamp
        AND d.adjClose IS NOT NULL
        AND d.adjClose != 0
        AND ($3 = 'all' OR s.scriptType = $3)
    ORDER BY d.stockid, d.timestamp DESC
),
stock_returns AS (
    SELECT
        l.stockid,
        ROUND((l.adjClose - o.adjClose) / o.adjClose * 100)::int AS return_percentage
    FROM latest_prices l
    JOIN one_year_ago_prices o ON l.stockid = o.stockid
)
SELECT
    s.id,
    s.name,
    s.symbol,
    sr.return_percentage
FROM stock_returns sr
JOIN stocks s ON sr.stockid = s.id
ORDER BY sr.return_percentage DESC
LIMIT $4
`

type GetTopStocksByReturnParams struct {
	Column1 pgtype.Timestamp
	Column2 int32
	Column3 interface{}
	Limit   int32
}

type GetTopStocksByReturnRow struct {
	ID               pgtype.UUID
	Name             string
	Symbol           string
	ReturnPercentage int32
}

func (q *Queries) GetTopStocksByReturn(ctx context.Context, arg GetTopStocksByReturnParams) ([]GetTopStocksByReturnRow, error) {
	rows, err := q.db.Query(ctx, getTopStocksByReturn,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopStocksByReturnRow
	for rows.Next() {
		var i GetTopStocksByReturnRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Symbol,
			&i.ReturnPercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
